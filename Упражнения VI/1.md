## Часть 1.

Наследование. Напишите класс по имени Adder, который экспортирует метод	add (self, х, у), выводящий сообщение Not Implemented (Не реализован).

Затем определите два подкласса класса Adder, которые реализуют метод add:

* ListAdderL c методом add, который возвращает сцепление своим двух списковых аргументов. 	
* DictAdderL c методом add, который возвращает новый словарь, содержащий элементы	из его двух словарных аргументов (подойдет любое определение словарного	дополнения).

[1](https://github.com/EnnerDA/Puthon_Lutz_MyConspect/blob/main/%D0%A3%D0%BF%D1%80%D0%B0%D0%B6%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20VI/1.1.py)

## Часть 2.

Поэкспериментируйте с интерактивным созданием экземпляров всех трех классов и вызовом их методов add. Затем расширьте суперкласс Adder для сохранения объекта в экземпляре с помощью конструктора (например, присвоив self.data список или словарь) и перегрузите операцию + посредством метода `__ add__` , чтобы автоматически направлять его вашим методам add (скажем, X + Y запускает X.add (X.data, Y)). Где лучше всего разместить конструкторы и методы перегрузки операций (т.е. в каких классах)? Какие разновидности объектов вы можете добавлять в экземпляры своих классов? 	
На практике вы можете обнаружить, что методы add легче реализовать для приема только одного реального аргумента (например, add (self, у)) и добавлять этот один аргумент к текущим данным экземпляра (наподобие self .data + у). 	
Имеет ли больше смысла поступать так, чем передавать add два аргумента? Сказали бы вы, что в итоге классы стали более “объектно-ориентированными”?	

[2](https://github.com/EnnerDA/Puthon_Lutz_MyConspect/blob/main/%D0%A3%D0%BF%D1%80%D0%B0%D0%B6%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20VI/1.2.py)
