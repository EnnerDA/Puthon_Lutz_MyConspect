# Часть I. Начало работы.
## Глава 1. Python в вопросах и ответах.

Питухон - великолепный язык, мы 60 страниц это доказываем.

## Глава 2. Как Python выполняет программы.

Исходный код компилируется в байт-код, который запускается на виртуальной машине Python.

Есть способы ускорить Python разными моделями реализации языка. IronPython, PyPy etc. М
ожно с помощью сторонних средств получить фиксированный двоичный файл.

## Глава 3. Как пользователь выполняет программы.

Вы обязаны инициализировать счетчики нулями, прежде чем сможете увеличивать их, инициализировать списки до их расширения и т.д.; вы не объявляете переменные, но им должны быть присвоены значения до того, как их можно будет извлекать.

*Программа - последовательность готовых операторов, сохраненных в файле для многократного выполнения.*

```
 % py scriptl.py > saveit.txt	
```
если ввести такое в командной строке, то результат выполнения скрипта сохранится в saveit.txt

Перва я строка в файле .py может быть *запускающим модулем.* В первой строке пишется #! подробнее в приложении В тома 2.

```python
>>> import script1
```
привелет к выполнению сценария script1.py , но только однократно. Считается, что импорт затратная операция, дальнейщие вызовы import script1 ничего не делают.
если требуется вызвать модуль заново, то
```python
from imp import reload
reload(module1)
```
Операции импорта обязаны искать файлы, компилировать их в байт-код и выполнять код.

*Модуль* - пакет имен переменным, известный под названием пространство имен, и имена внутри такого пакета называются - *атрибутами*. Т.е. *атрибут* - это имя переменной, которая прикрепляется к специфическому объекту (вроде модуля).

Формально `from` копирует атрибуты модуля, так что они становятся просто переменными на принимающей стороне.

Функция `dir` вызывается с именем импортированного модуля в круглых скобках, она возвращает все атрибуты внутри 	
модуля. Имена с ведущими и завершающими двойными подчеркиваниями (__ X__) являются встроенными именами.
```python
>>> dir(treenames) 
[’__builtins__	', '__ doc__	’_____ file__ ', '__ name__	', '__ package__', ’a’, ’b’, 'c']
```

Вызов встроенной функции `exec(open('module.ру').read())` является приемом запуска файлов без импортирования и последующей перезагрузки.

**!**  `ехес` работает, как если бы вы поместили код на его место, потенциально он способен молча переписать переменные, которые используются в текущий момент.	

*IDLE* - интегрированная среда разработки (integrated development environment — IDE в общеам случае и IDLE в случае стандартной питоновской среды, названой спциально с ошибкой). Графический пользовательский интерфейс, который позволяет редактировать, выполнять, просматривать и отлаживать программы Python, используя единый интерфейс.
IDLE можно запустить из консоли `% py -m idlelib.idle`
 
Для прокрутки ранее написанных команд можно использовать <Alt+P>/<Alt+N>. 

Повторять команды можно также путем перемещения на них курсора с последующим щелчком и нажатием <Enter> для вставки их текста в строку с приглашением.
 
Применяйте отладчик командной строки pdb.

Применяйте аргумент -i команды python	(например, python -i m.py). Когда сценарий закончит работу, либо успешно дойдя до конца, либо из-за возникновения ошибки вы сможете вывести финальные значения переменных, чтобы получить больше деталей.

# Часть II. Типы и операции.
 
## Глава 4. Введение в типы объектов Python.

Концептуальная иерархия Python:
1. Программы состоят из модулей.
2. Модули содержат операторы.
3. Операторы содержат выражения.
4. Выражения создают и обрабатывают объекты.

Обзор встроенных типов объектов:

![Обзор встроенных типов объектов:](https://user-images.githubusercontent.com/116806816/202090225-28e7bae0-31f9-43aa-b9ef-6d8c2479db4f.png)

*Последовательность* - позиционно упорядоченая коллекция других объектов.

Операции эквивалентны:
```python
S = 'spam'
S[-1] == S[len(S)-1]
```
Интересный синтаксис:
```python
>>>S[:-1] #выдать все кроме последнего элемента
'spa'
```
Строка - неизменяемый объект. мы можем построить новый на ее основе но не поменять саму строку:
```python
>>> s = 'spam'
>>> s[0] = z
Traceback (most recent call last):
  File "<pyshell#12>", line 1, in <module>
    s[0] = z
NameError: name 'z' is not defined
>>> s = 'z' + s[1:]
>>> s
'zpam'
```
Кортежи, строки, числа - неизменяемы. Списки, словари, множества - изеняемы.
 
Функция `dir` просто выдает имена методов. Чтобы выяснить, что делает тот или иной метод, его имя можно передать функции `help`:

```python
>>> help(s.index)
Help on built-in function index:

index(...) method of builtins.str instance
    S.index(sub[, start[, end]]) -> int
    
    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.
    
    Raises ValueError when the substring is not found.
```
Можно запрашивать `help` по целым классам, например `help(str)' выдаст описание всех строковых методах.

**Строки**
Операции над строками:
* \+ сложение (конкатенация)
* \* повторение
* [:] нарезание
* [1] индексирование


Для сопоставления с образцом в Python мы используем модуль `re`. Синтаксис его не явный и я нихрена не понял.

**Списки** 

*Списки*  - позиционно упорядоченные коллекции объектов произвольных типов и не имеют фиксированных размеров. Кроме того, они изменяемы — в отличие от строк списки можно модифицировать на месте путем присваивания по смещениям и вызова разнообразных списковых методов.

Операции над списками:
* теже что и для строк +
* добавление объекта в конец списка `spisok.append(new_element)`
* удаление элемента из середины `spisok.pop(2)`, в скобках указан индекс удаляемого элемента.
* `del spisok[1]`, удаляет элемент из списка.
* `isnsert`, `remove`, `extend` и т.д.
* `spisok.sort()`, `spisok.reverse()` меняют порядок следования элементов.

Поскольку списки являются зменяемыми, большинство списковых методов также модифицируют объект спискаа месте, а не создают новый такой объект	

Вложения - можно вкладывать в список списки, словари, и любые типы данных на любую глубину.
```python
m = [[1,2,3],
     [4,5,6],
     [7,8,9]]
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> m[1][0]
4
```
**Списковые включения**
Получать строки легко посредством простой индексации, потому что матрица хранится по строкам, но получить столбец почти так же легко с помощью спискового включения:
```python
>>> col2 = [row[1] for row in m]
>>> col2
[2, 5, 8]
>>> [row[1] + 1 for row in m] # добавить 1 к каждому значению row[1]
[3, 6, 9]
>>> [row[1] for row in m if row[1]%2 == 0] # вернуть только четные значения row[1]
[2, 8]
```
Интересный синтаксис:
```python
>>> list(range(-6,6,2))
[-6, -4, -2, 0, 2, 4]
>>> [[x**2, x**3] for x in range(4)]
[[0, 0], [1, 1], [4, 8], [9, 27]]
>>> [[x, x/2, x*2] for x in range(-6,7,2) if x > 0]
[[2, 1.0, 4], [4, 2.0, 8], [6, 3.0, 12]]
```
```python
>>> list(map(sum, m))
[6, 15, 24]
```
Создание словарей:
```python
{x: ord(x) for x in 'spaam'}
```
функция `ord` возвращает численный код Unicod заданого символа.

**Словари**

*Словари* Python - это *отображения*, коллекции других элемнентов, но объекты храняться по ключам, а не по относительным позициям. Являются изменяемыми.  
```python 
rec = {'name': {'first': 'bob', 'last': 'smith'},
       'jobs': ['dev', 'mgr'],
       'age': 40.5}
```
Проверка нахождения ключа в словаре:
```python
if 'name' in rec:
    print('good')
```
Интересный синтаксис:
```python
>>> value = rec['x'] if 'x' in rec else 1 #проверка на вхождение ключа 'x' в словарь rec и ветвление в одной строке
>>> value
1
```
Если требуется навязать порядок в последовательности элементов словаря, то вот вариант:

1. Получаем список ключей методом `keys()`
2. Сортируем этот список методом `sort`
3. Теперь можем пройти все ключи в нужном порядке циклом `for`
```python
>>> ks = list(rec.keys())
>>> ks
['name', 'jobs', 'age']
>>> ks.sort()
>>> ks
['age', 'jobs', 'name']
>>> for key in ks:
        print(key, '=>', rec[key])

age => 40.5
jobs => ['dev', 'mgr']
name => {'first': 'bob', 'last': 'smith'}
```
Тот же результат получим если напишем так:
```python
>>> for key in sorted(rec):
    print(key, '=>', rec[key])
```

**Кортежи**
 
*Кортежи* - неизменяемая последовательность элементов.
```python
>>> t = (1, 2, 3, 4)
>>> type(t)
<class 'tuple'>
>>> t[0] # индексацияб нарезание и т.д.
1
 >>> t.index(4) # возвращает индекс элемента со значением 4
3
>>> t.count(4) # считает количество элементов со значением 4
1
>>> t[0] = 2 # выдаст ошибку, т.к. кортежи не изменяемы!
```

**Файл**
Пример создания
```python
>>> f = open('data.txt', 'w')
>>> f.write('hello\n')
6
>>> f.close()
```
В сценарии содержимое файла всегда будет строкой независимо от типа находящихся в нем данных.
Файлы предлагают итераторы для своего чтения: `for line in open(’data.txt’): print(line)`

Для кодирования и декодирования используем `encode` / `decode`:
```python
>>> text = 'abcdefg'
>>> text.encode('utf-8')
b'abcdefg'
>>> rutext = 'абвгде'
>>> rutext.encode('utf-8')
b'\xd0\xb0\xd0\xb1\xd0\xb2\xd0\xb3\xd0\xb4\xd0\xb5'
>>> crokazyab = b'\xd0\xb0\xd0\xb1\xd0\xb2\xd0\xb3\xd0\xb4\xd0\xb5'
>>> crokazyab.decode('utf-8')
'абвгде'
```

**Прочие типы***

*Множество* - неупорядоченная последовательность уникальных элементов. Задаются функцией `set`.
```python
>>> x = set('spam')
>>> y = {'h', 'a', 'm'}
>>> x,y
({'m', 's', 'a', 'p'}, {'m', 'h', 'a'})
>>> x&y # пересечение
{'m', 'a'}
>>> x|y # объединение
{'h', 'm', 's', 'a', 'p'}
>>> x - y # разность
{'s', 'p'}
>>> x > y # надмножество
False
>>> {n**2 for n in range(4)}
{0, 1, 4, 9}
```

**Классы, определяемые пользователем**

Классы определяют новые типы объектов, которые расширяют основной набор.

## Глава 5. Числовые типы.

![изображение](https://user-images.githubusercontent.com/116806816/202360309-952f14e7-a5a2-4e17-abff-674bb365bf6a.png)

![изображение](https://user-images.githubusercontent.com/116806816/202364052-0a3d73f1-5af9-4b26-a305-eed12b8bab00.png)

Операции, находящиеся ниже в табл. 5.2, имеют более высокий приоритет и потому в смешанных выражениях вычисляются раньше. 	

Операции, расположенные в одной строке табл. 5.2, обычно группируются слева направо, когда они скомбинированы (за исключением возведения в степень, которое группируется справа налево, и сравнений, выстраиваемых в цепочку слева направо).	

Например: x + y * z Python первым выполнит y * z а затем уже сложение.

Применение круглых скобок переопределяет порядок и вообще улучшает читабельность.

```python
>>> 1 == 2 < 3 # тоже, что и 1 == 2 and 2 < 3
False
```
**!!!** Важный пример
```python
>>> 1.1 + 2.2 == 3.3
False
>>> 1.1 + 2.2
3.3000000000000003 # ограниченная точность
```
Причина связана с тем фактом, что числа с плавающей точкой не способны представлять определенные значения точно из-за ограниченного количества битов — фундаментальная проблема в численном программировании, не уникальная для языка Python.	

`//` -  деление с округлением, в меньшую сторону — она усекает результат до ближайшего целого значения, которое меньше подлинного результата. В отрицательных числах результат такой:
```python
>>> -9/4
-2.25
>>> -9//4
-3
```

Если требуется усечение в сторону 0, то лучше прогнать функцию `math.trunc`.
```python
>>> import math
>>> math.trunc(-9/4)
-2
```
**Комплексные числа** записываются 
```python
>>> 2+2j
(2+2j)
```
Отлично обрабатываются стандартным модулем cmath.

Но, надо быть аккуратнее и постараться не называть переменные `j`, мало ли путаницу внесу случайно.

**Не десятичные системы исчисления**
 
* `oct` преобразует десятичное число в восьмеричное 
* `hex` — в шестнадцатеричное
* `bin` — в двоичное	
 
Если вы обнаруживаете, что хотите манипулировать битами в Python, то должны подумать о том, тот ли язык вы используете для реализации программы.
 
 **Дргуие встроенные инструменты**
 
 ```python
>>> import math
>>> math.pi, math.e # классические константы
(3.141592653589793, 2.718281828459045)
>>> math.sin(math.pi/2) # тригонометрические функции
1.0
>>> math.sqrt(144) # квадратный корень
12.0
 >>> abs(-42) # абсолютное значение (модуль)
42
>>> sum((1,8,6,4)) # сумма, работает на последовательности
19
>>> min(3,1,2,4), max(3,1,2,4) # минимум, максимум
(1, 4) 
>>> math.floor(2.567), math.floor(-2.567) # округление в меньшую сторону (до меньшего целого)
(2, -3)
 >>> round(2.467), round(2.567), round(2.567, 2) # нормальное округление
(2, 3, 2.57)
 >>> '%.1f' %2.567, '{0:.2f}'.format(2.567) # округление для отображения
('2.6', '2.57')
```
```python
>>> import random # модуль случайностей
>>> random.random() # случайное число с плавающей точкой от 0 до 1
0.7048912341014086
>>> random.randint(1,10) #  случайное целое число в указаном диапазоне
6
>>> spisok = ['a', 'b', 'c', 'd']
>>> random.choice(spisok) # выбор случайного элемента из списка
'b'
>>> random.shuffle(spisok) # перемещать список
>>> spisok
['b', 'd', 'a', 'c']
 ```
**Другие числовые типы**
 
 **Десятичные**
 
 Из-за вот такой математики могут возникнуть ошибки
 ```python
 >>> 0.1+0.1+0.1-0.3
5.551115123125783e-17
 ```python
>>> from decimal import Decimal
>>> Decimal('0.1') +Decimal('0.1')+Decimal('0.1')-Decimal('0.3')
Decimal('0.0')
 ```
 Однако если использовать float() в качестве аргумента:
 ```python
 Decimal(0.1) +Decimal(0.1)+Decimal(0.1)-Decimal(0.3)
Decimal('2.775557561565156540423631668E-17')
 ```
 Можно установить глобальную точность для десятичных чисел:
```python
>>> import decimal
>>> decimal.getcontext().prec=4
>>> Decimal(0.1) +Decimal(0.1)+Decimal(0.1)-Decimal(0.3)
Decimal('1.110E-17')
```
 не понятно тогда зачем всё это?!

 **Дробный тип**
 
Тип Fraction реализует объект рационального числа. По существу он явно хранит числитель и знаменатель.	
```python
 >>> from fractions import Fraction
>>> x = Fraction(1,3)
>>> x
Fraction(1, 3)
>>> print(x)
1/3
>>> 1 - x
Fraction(2, 3)
```
Можно создавать дробные числа из чисел с плавающей запятой
``` python 
>>> y = Fraction(0.25)
>>> y
Fraction(1, 4)
```
Таким образом можно получить точные математические вычисления, но со снижением скорости и читабельности кода.
 ```python
 >>> 0.1+0.1+0.1-0.3 # стандартная математика
5.551115123125783e-17
>>> 5.551115123125783e-17 == 0
False
# Дробная
>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)
Fraction(0, 1)
>>> Fraction(0, 1) == 0
True
# Десятичная
>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
Decimal('0.0')
>>> Decimal('0.0') == 0
True
```
Еще способ представления в кчестве дроби
 ```python
>>> (4/3).as_integer_ratio()
(6004799503160661, 4503599627370496)
>>> a = Fraction(*(4/3).as_integer_ratio())
>>> a
Fraction(6004799503160661, 4503599627370496)
>>> a.limit_denominator(10)
Fraction(4, 3)
>>> a
Fraction(6004799503160661, 4503599627370496)
``` 
 Иногда для сохранения точности придется преобразовывать данные вручную:
 ```python
 >>> x+1/3
2.666666666666667
>>> x + Fraction(1,3)
Fraction(8, 3)
 ```
 **Множества**
 
 *Множество* - неупорядоченная коллекция уникальных неизменяемых элементов, которая подджерживает операции математической теории множеств. Множества итерируемы, могут увеличиваться, уменьщаться и содержать объекты разнообразных типов. Создаётся функцией `set`.
 ```python
>>> x = set('abcde')
>>> y = set('bdxyz')
# Операции над множествами
 >>> x-y # Разность
{'e', 'c', 'a'}
>>> x|y # Объединение
{'c', 'a', 'z', 'x', 'd', 'y', 'e', 'b'}
>>> x&y # Пересечение
{'b', 'd'}
>>> x^y # Симметрическая разность (исключающее ИЛИ)
{'e', 'x', 'y', 'z', 'c', 'a'}
>>> x > y, x < y # Надмножество, подмножество
(False, False)
>>> 'e' in x # проверка вхождения
True
 ```
 Методы
 ```python
 >>> x.add('SPAM') # Вставка элемента
 {'c', 'a', 'd', 'e', 'b', 'SPAM'}
 >>> x.update(['x','k','z'] # Слияние: объединение на месте
 >>> x.remove('b') # удаление одного элемента
 >>> x
 {'c', 'a', 'z', 'x', 'd', 'e', 'k', 'SPAM'}
 ```
 Множества могут содержать только объекты неизменяемых типов. Следовательно списки, словари не могут встраиваться во множества, но кортежи могут. 
 ```python
 >>> s.add([1,2,3])
 TypeError: unhashable type: 'list'
 >>> s.add({a:1})
 TypeError: unhashable type: 'dict'
 >>> s.add((1,2,3))
>>> s
{1, (1, 2, 3)}
 >>> s|{(4,5,6), (1,2,3)}
{1, (1, 2, 3), (4, 5, 6)}
 ```
Функция `frozenset` работает в точности как `set`, но создает неизменяемое множество, которое не допускает модификацию и потому может быть внедрено в другие множества.

Включения множеств:
 ```python
 >>> {x**2 for x in [1,2,3,2,4]}
{16, 1, 4, 9}
>>> {x for x in 'spramm'}
{'p', 'a', 's', 'm', 'r'}
 ```
 
 **Булевские занчения**
 
 `True == 1` и `False == 0`
 
 **Численные расширения**
 
Если вам необходимо заниматься серьезным перемалыванием чисел, то дополнительное расширение для Python под названием NumPy (Numeric Python) предоставляет расширенные инструменты численного программирования, такие как матричный тип данных, обработка векторов и библиотеки сложных вычислений.

 ## Глава 6. Кратко о динамической типизации.

Порядок действий при ситуации:
```python
a = 3
```
1. Создание объекта для представления значения 3.
2. Создание переменной а, если она не существует.
3. Связываение а с новым объектом 3.

* Объекты - это области выделенной памяти с достаточным пространством для предоставления значений, для которых они предназначены.
* Переменные - это записи в системной таблице, в которых предусмотрены места для связей с объектами.
* Ссылки - это следуемые указатели от переменных к объектам.

Каждый объект содержит два стандартных заголовочных поля: *обозначение типа*, применяемое для пометки типа объекта, и *счетчик сылок*, используемый для определения, когда можно освободить память, которую занимает объект.

---
**Именяемые типы в Python: списки, словари и множества.**
---

 ```python
>>> a = 2 # а - это просто ссылка на объект int со значением 2 
>>> b = a # b - d не ссылается на а, вместо а подставляется ссылка на объект,
          # так что b это ссылка на объект int со значением 2
>>> a, b
(2, 2)
>>> a = 24 # теперь а ссылкается на другой объект
>>> a,b
(24, 2) # но b никто не менял, она по прежднему сслыка на объект int со значением 2
# НО!!!
>>> a = [1,2,3] 
>>> b = a # a и b сслыкаются на один и тот же объект list
>>> a[0]=124 # меняем на ходу один из элементов этого объекта
>>> a,b
([124, 2, 3], [124, 2, 3]) # a и b продолжают ссылкаться на этот list, не смотря на то что он изменен
```
 Если нам не требуется такое поведение то мы можем запросить копию объекта:
 ```python
>>> a = [1,2,3]
>>> b = a[:] # или list(a), copy.copy(a), и т.д.
>>> a,b
([1, 2, 3], [1, 2, 3])
>>> a is b
False
>>> a[0] = 123
>>> a,b
([123, 2, 3], [1, 2, 3])
 ```
 Для словарей и множест нарезка не подходит так как они не являбются последовательностями. Для них нужно использовать модуль `copy`.
 ```python
 import copy
 x = copy.copy(y) # создаёт поверхностную копию верхнего уровня
 x = copy.deepcopy(y) # создаёт глубокую копию, полностью копируя все вложенные части
```
 
 В учебнике сказано, что со строками и числами ссылки будут указывать на один и тот же объект даже в случе копирования из-за того что эти объекты попадают в кэш. Хотя вообще по логике в случае неизменяемых объектов нет смысла создавать копию, я б в логике языка так и оставлял ссылку на объект. 
 ```python
 >>> a = 1.32131
>>> b = a
>>> a is b
True
>>> b = copy.copy(a)
>>> a == b
True
>>> a is b
True
import sys
 >>> sys.getrefcount(1.32131) # указывает количество ссылок на объект
2
 ```
 Существует термин *слабая ссылка* - это такая ссылка, которая не препятствует сборке мусора. Т.е. если последними оставшимися сслыками на объект оказываются слабые сслыки, тогда выдеоенная под объект память освобождается.
 
## Глава 7. Фундаментальные основы строк.

*Строка* - упорядоченная коллекция символов. Является первым представителем более крупного класса *последовательности*.

![image](https://user-images.githubusercontent.com/116806816/202838994-92b820c2-3cf2-41cd-8246-85cccc062822.png)

![image](https://user-images.githubusercontent.com/116806816/202839019-3174f4aa-6a74-4332-97b2-a4b5ec033097.png)

Обратная косая черта используется для введения специальных кодировок символов, известных как *управляющие последовательности*.

![image](https://user-images.githubusercontent.com/116806816/202840965-1930d939-4091-4f74-b23b-a2d5a3d81906.png)

 Если перед кавычкой поставить `r`, то это будет неформатированная строка. Неформатированные строки подавляют управляющие последовательности. Их удобно использовать для написания адресов, дабы обратная косая черта не создавала управляющий символ.
 ```python
 b = r'С:\new\text.dat
 ```
 *Блочные строки* - многострочный текст обособленный тремя кавычками, двойнми или одинарными не важно, главное что б какие в начале - такие и в конце.
 Используются, когда нужно вставить многострочный текст, код HTML, XML, JSON, либо для строк документации как большой комментарий к кодуб либо для временного отключения нескольких строк кода.
 
**Базоввые операции**
 
 ```python
>>> a = 'abcdefg'
>>> for c in a: print(c, end = '!')
a!b!c!d!e!f!g!
```
Расширенное нарезание (S [i: j :k] ) принимает шаг (или страйд (большой шаг)) к, который по умолчанию равен +1. Например для смены порядка можно `S[::-1]`, или `S[::2]` для извлечения элементов только с четным индексом. 
 При отрицательном страйде (*страйд* - шаг) смысл первых двух границ по существу изменяется на противоположный. Таким образом, срез S [5:1: -1] извлекает элементы со второго по пятый в обратном порядке (результат содержит элементы по смещениям 5, 4, 3 и 2).
 
 Преобразование символа в его внутренний целочисленный код.
 ```python
 >>> ord(s)
 115
 >>> chr(115)
 's'
 ```
 Преобразование строки двоичных цифр в целоеЖ
 ```python
 >>> int('1101', 2)
 13
 >>> bin(13)
 '0b1101'
 ```
 
 **Изменение строк**
 
 *Извлечение атрибутов*
 
*Объект.Атрибут* означает извлечь атрибут из объекта.
 
 *Выражение вызова* 
 
 *Функция(Аргументы)* означает вызвать код функции передав ему некоторое количество аргументов через запятую и возвратить результирующее значение функции.
 
 Объединение этих двух операций позволяет вызывать *Метод Объекта*.
 
 *Объект.Метод(Аргумент)* это означает Вызвать метод для обработки объекта с аргументами.
 
 43 строковых метода, в квадратных скобках необязательные аргументы.
 
 ![изображение](https://user-images.githubusercontent.com/116806816/202975199-97b22767-d242-4b5b-91d3-aeb9c42d8958.png)

 **Методы:**
  
* Нарезание  `s = s[:10:2] + 'xx' + s[5:]`
 
* `replace` - замена подстрок, можно использовать необязательный третий аргумент для ограничения количесва замен.
```python
>>> 'aa$bb$cc$dd'.replace('$', 'SPAM', 2)
'aaSPAMbbSPAMcc$dd'
```
* `find` - поиск подстроки, вернет -1 если не найдет. 
```python
>>> s = 'xxxxSPAMxxxxSPAMxxxx'
>>> where = s.find('SPAM')
>>> where 
4
>>> s = s[:where] + 'EGGS' + s[(where + len('EGGS')):]
>>> s
'xxxxEGGSxxxxSPAMxxxx'
```
* Сборка из частей в строку `list` -> `json`. В обзем случае метод выглядит так: `'Разделитель'.join(Итерируемый объект)`
```python
>>> s = 'spammy'
>>> l = list(s)
>>> l
['s', 'p', 'a', 'm', 'm', 'y']
>>> l[3] = l[4] = 'x'
>>> s = ''.join(l)
>>> s
'spaxxy'
```
* Разбор строки на части `split` разбивает строку на список подстрок согласно строке разделителя, по умолчанию разделитель - пробел.	
```python
>>> line = 'aaa bbb ccc'
>>> line.split()
['aaa', 'bbb', 'ccc']
>>> line = 'aaa,bbb,ccc'
>>> line.split(',')
['aaa', 'bbb', 'ccc']
```
* Другие строковые методы:
 
 ```python
 >>> line = 'The knights who say Ni!\n'
>>> line.rstrip() # убирает пробелы, табуляции и пр. Можно выбрать rstrip(), lstrip() 
                  # или с обеих сторон strip()
'The knights who say Ni!'
>>> line.upper() # смена регистра. Обратный метод lower()
'THE KNIGHTS WHO SAY NI!\n'
>>> line.isalpha() # возвращает True если строка содержит только буквы
False
>>> sub  = 'Ni!\n'
>>> line.endswith(sub) # проверка окончания строки через метод
True
>>> line[-len(sub):] == sub # проверка окончания строки через срез
True
```

 **Форматирование строк**
 
 Для форматирования строки, делим ее на две части:
 
 1. Слева от операции `%` пишем строку содерждащую одну или более встроенных целей, каждая из которых начинается с % с параметром (например, `%s`).
 2. Справа от операции `%` указываем объект (или объекты, внедренные в кортеж), который необходимо вставить в строку формата слева на месте цели (или целей).
 
 ```python
 >>> 'that is %d %s bird!' %(1, 'dead')
'that is 1 dead bird!'
 ```
 Код в правой части указывает тип вставляемых данных и содержит символы для форматирования. Общая структура такова:
 
 `%[(имя ключа)][флаги][ширина][.точность]код типа	
 
 1. Имя ключа смотрим по таблице
 
 ![изображение](https://user-images.githubusercontent.com/116806816/202997288-e5183fec-db80-403f-a64c-83b9c88d9a61.png)
 
 2. Флаги указывают аспекты вроде выравнивания влево (-), знак числа (+), пусто перед положительными числами и — для отрицательных чисел (пробел) и дополнение нулями (0).

 3. Общая минимальную ширину поля для подставляемого текста.
 
 4. Количество цифр, отображаемых после десятичной точки (точность), для чисел с плавающей точкой.
 
 ```python
>>> 'Пример %.2f' %(1/3) # код f означает число с плавающей точкой
                         # .2 значит два знака после запятой
'Пример 0.33'
>>> 'Пример %.*f' %(4, 1/3) #* значит взять количество цифр после запятой из кортежа. т.е. 4
'Пример 0.3333'
>>> 'Пример %+08.1f'%(100/3) # дополнить нолями слева запись до 8 символов, при этом 1 после запятой. 
                             # выделить положительное число +
'Пример +00033.3'
>>> 'Пример %08.1f'%(100/3) # тоже но не выделяют положительно число +
'Пример 000033.3'
>>> 'Пример %-08.1f'%(100/3) # дополнить пробелами справа до 8 символов.
'Пример 33.3    '
 ```
 **Отличный пример на странице 254 просто оставлю ссылку тут ибо тут все что ли переписывать?!?!**
 
 Форматирование со словарями.
 ```python
 >>> reply = """
Good day
Hello %(name)s!
Your age is %(age)s
"""
>>> values = {'name': 'Bob', 'age': '23'}
>>> print(reply%values) # ВНИМАНИЕ ЧУДЕСА!

Good day
Hello Bob!
Your age is 23
``` 
Интересная штука с встроенной функцией `vars` - `vars()` содердит словарь всех переменных объекта.

```python
>>> eny_numb = 23
>>> eny_word = 'PrumPurum'
>>> 'Numb - %(eny_numb).2f, word - %(eny_word)s' % vars()
'Numb - 23.00, word - PrumPurum'
```

 ** Форматирование строк вызовом метода**
 
Фигурные скобки внутри строки, на которой метод вызывается, обозначают цели подстановки и аргументы, вставляемые по позиции (например, {1}), поключевому слову (скажем, {food}) или по относительной позиции ({}).
```python
>>> pr3 = '{aaa} and {aaa} und {ccc}, and enother {bbb}'
>>> pr3.format(aaa = 'qqq', bbb = 'www', ccc = 'eee')
'qqq and qqq und eee, and enother www'
```
Извлечение атрибута в рамках форматирования:
 ```python
>>> import sys
>>> 'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'Laptop'})
'My Laptop runs win32'
```
Нарезание в рамках форматирования
 ```python
>>> some_list = list('SPAM')
>>> new_str = 'first = {0[0]}, third = {0[2]}'.format(some_list)
>>> print(new_str)
first = S, third = A
```
 
**Типы**
 
 |Изменяемые|Неизменяемые|
 |---|---|
 |списки, словари, множества, байтовые массивы|числа, строки, кортежи, фиксированные множества|
 
 
 ## Глава 8. Списки и словари.
 
 **Списки**
 
 ![image](https://user-images.githubusercontent.com/116806816/203090116-7362a94b-5889-4c36-b2d1-f1a9471f112f.png)

 ![image](https://user-images.githubusercontent.com/116806816/203090245-caa165d3-f4e7-4fa5-8913-28e089d6c586.png)

```python
>>> L = [1,2,3]
>>> L[1:2] = [4,5] # замена элемента с индеком 1/вставили
>>> L
[1, 4, 5, 3]
>>> L[1:1] = [6,7] # вставка после элемента с индексом 1 ничего не удалили
>>> L
[1, 6, 7, 4, 5, 3]
>>> L[1:2] = [] # удалили элемент с индексом 1
>>> L
[1, 7, 4, 5, 3]
>>> L.append(8) # добавить элемент в конец
[1, 3, 4, 5, 7, 8]
>>> L.sort()
>>> L
[1, 3, 4, 5, 7, 8]
>>> L + [9] # создаст новый список, а append() меняет существующий
[1, 3, 4, 5, 7, 8, 9]
>>> L
[1, 3, 4, 5, 7, 8]
>>> L.insert(0, 6) #вставка в заданную позицию
>>> L
[6, 1, 3, 4, 5, 7, 8]
```
Существует и функция сортировки, роторая возвращает новый объект (действует и с другими коллекциями)
```python
>>> L = ['abc', 'ABD', 'aBe']
>>> sorted(L, key=str.lower, reverse = True)
['aBe', 'ABD', 'abc']
>>> sorted([x.lower() for x in L])
['abc', 'abd', 'abe']
```
**Ещё немного списковых методов**
```python
>>> L = [1,2]
>>> L.extend([3,4,5]) #добавление множества элементов в конец
>>> L
[1, 2, 3, 4, 5]
>>> L.pop() # удаление и возврат последнего элемента
5
>>> L.pop(1) # тоже по заданому индексу
2
>>> L.reverse()
>>> L
[4, 3, 1]
>>> list(reversed(L)) #функция list нужна т.к. reversed() возвращает итератор 
[1, 3, 4]
```
и ещё чуть чуть методов
```python
>>> L = ['spam', 'eggs', 'ham']
>>> L.index('eggs') #индекс объекта
1
>>> L.insert(1, 'toast') # вставка в указанную позицию
>>> L
['spam', 'toast', 'eggs', 'ham']
>>> L.remove('eggs') # удаление по значению
>>> L
['spam', 'toast', 'ham']
>>> L.count('spam') #количество вхождений
1
>>> del L[1] # удалять можжно целыми срезами, например [2:7]
>>> L
['spam', 'ham']
```

**Словари**
![изображение](https://user-images.githubusercontent.com/116806816/203225929-064f66f1-239a-45d3-8cf6-46c443e204cc.png)

Извлечение по несуществуюшему ключу выдаст ошибку, но можно приментить метод `get`.
```python
>>> print(D.get('spam'))
None
>>> D.get('spam', 16) # 16 то что выдаст пуе если не найдет значение по ключу 'spam'
16
>>> D.get('name') # ну если ключ есть, то выдаст значение по ключу
'Bob'
 ```
 
 Обычная конкатенация вызовет ошибку, но можно использовать медот `update`
 ```python
>>> D2 = {'eggs':3, 'toaste':4}
>>> D+D2
TypeError: unsupported operand type(s) for +: 'dict' and 'dict'
>>> D.update(D2)
>>> D
{'name': 'Bob', 'age': 40, 'eggs': 3, 'toaste': 4}
```

Метод `pop` удаляет ключ из словаря возвращаязначение по ключу
```python
>>> D.pop('age')
40
>>> D
{'name': 'Bob', 'eggs': 3, 'toaste': 4}
>>> D.pop('horse', 'No horse') # можно указать что вернуть если ключ не будет найденю
'No horse'
```
Далее словарь отображает названия на годы, но если нам нудно найти ключ по значению, например хотим узнать фильм для 1975 года, можно использовать такой метод:
```python
>>> table
{'Holly Grail': '1975', 'Life of Brian': '1979', 'The Meaning of Life': '1983'}
>>> list(table.items())
[('Holly Grail', '1975'), ('Life of Brian', '1979'), ('The Meaning of Life', '1983')]
>>> [title for (title, year) in table.items() if year == '1975']
['Holly Grail']
```
или еще проще:
```python
>>> [key for key in table.keys() if table[key] == '1975']
['Holly Grail']
```
но что если не один кулюч имеет такое значение? ататааааа

**Словари это отображения а не последовательности**

Ключами могут быть любые неизменяемые объекты даже кортежи.
```python
>>> Matrix = {}
>>> Matrix[(2,3,4)] = 88
>>> Matrix[(7,8,9)] = 99
>>> x,y,z = 2,3,4
>>> Matrix[(x,y,z)]
88
>>> Matrix
{(2, 3, 4): 88, (7, 8, 9): 99}
```
**Избегание ошибок с отстутствующими ключами**

**1. оператором `if`**
```python
if (2,3,4) in Matrix:
    print(Matrix[(2,3,4)])
else:
    print(0)
```
**2. Оператором `try`**
```python
try:
    print(Matrix[(2,3,6)])
except KeyError:
    print(0)
```
**3. Словарным методом `get`**
```python
Matrix.get((2,3,4),0)
```
Словарь можно создавать вот так вот красиво:
 ```python
 >>> rec = {'name': 'Bob',
       'jobs': ['developer', 'manager'],
       'web': 'www.bobs.org/~Bob',
       'home': {'state': 'Overworked', 'zip': 12345}}
 ```
 
 Для сравнения создадим одинаковые базы данных списком и словарем:
```python
>>> db = []
>>> db.append(rec)
>>> db.append(other)
>>> db[0]['jobs']
['developer', 'manager']
>>> db = {}
>>> db['bob'] = rec
>>> db['sue'] = other
>>> db['bob']['jobs']
['developer', 'manager']
 ```
База из словаря проще в написании и нагляднее в использовании в данном случае. 
 
 **Способы создания словарей:**
 
1. Традиционная литеральная
 ```python
>>> {'name': 'Bob', 'age':40}
 ```
 Удобна, если можно записать словарь заранее. 
 
 2. Динамическое присваивание по ключам
 ```python
 >>> D = {}
>>> D['name'] = 'Bob'
>>> D['age'] = 40
 ```
 Такая форма используется когда нужно создать словарь на лету по одному полю за раз.
 
 3. dict с ключевыми аргументами
 ```python
 >>> dict(name = 'Bob', age = 40)
 ```
 Меньший объем набора текста чем в случае 1, но все ключи должны быть строками.
 
 4. dict с кортежами "ключ/значение"
 ```python
 >>> dict([('name', 'Bob'), ('age', 40)])
 ```
Применяется, если ключи и значения нужно накапливать как последовательности во время выполнения.
 
`D.keys()`, `D.values()` и `D.items()` возвращают итерируемые представления, подобные множествам, вместо списков.
А вот 'list(D.keys())' уже вернет список.
 
 **Включения словарей**
 
 Встроенная функция `zip` — это прием, который позволяет создавать словарь из списков ключей и значений. В общем она ассоцирует по порядку элементы двух коллекций. 
```python
>>> list(zip(['а', 'b', 'o'], [1,2,3]))
[('а', 1), ('b', 2), ('o', 3)]
>>> set(zip(['а', 'b', 'o'], [1,2,3]))
{('а', 1), ('b', 2), ('o', 3)}
>>> dict(zip(['а', 'b', 'o'], [1,2,3]))
{'а': 1, 'b': 2, 'o': 3}
```
Реализация включений словарей:
 
```python
>>>  D = {k: v for k,v in zip(['а', 'b', 'o'], [1,2,3])} #через zip
>>> A = {k: k**2 for k in range(10)} # квадраты чисел до 10
>>> B = {c: [c.lower(), c.upper()] for c in 'SpAm'}  # из строки
>>> C  = dict.fromkeys('spam') # с методом fromkeys() из любых итерируемых объектов
>>> C
{'s': None, 'p': None, 'a': None, 'm': None}
 ```
Объекты представлений возвращаемые методом keys, подобны множествам и поддерживают распространенные операции над множествами, такие как пересечение и объединение; представления values не подобны множествам, но результаты items подобны, если их пары (ключ, значение) уникальны и хешируемы (неизменяемы).	
 
 ```python
 >>> K,V
(dict_keys(['a', 'c']), dict_values([1, 3]))
 >>> K|{'x':4} # логическое ИЛИ, объединение множеств
{'a', 'x', 'c'}
 
 >>> V&{'x':4} # логическое И, пересечение множеств
 TypeError: unsupported operand type(s) for &: 'dict_values' and 'dict'
 >>> V&{'x':4}.values()
 TypeError: unsupported operand type(s) for &: 'dict_values' and 'dict_values'
 # values не подобны множествам
 
 >>> A
{'a': 1, 'c': 3}
>>> D = {'b': 2}
>>> A.keys()|D.keys() # способ использовать операции над множествами
{'a', 'c', 'b'} 
 ```
Сортировка ключей словаря:
 
 `D.keys()` не сортируется, нужно вручную перевести ее в список а хатем сортировать.
 ```
>>> Ak = list(A.keys())
>>> Ak.sort()
>>> Ak
['a', 'c']
```
 ## Глава 9. Кортежи, файлы и всё остальное.
 
 *Кортеж* - позиционно упорядоченная неизменяемая коллекция произвольных объектов.

 ![изображение](https://user-images.githubusercontent.com/116806816/203474964-159d5abb-9a7a-4867-a441-d20dead3901b.png)

 Отсортировать кортеж можно с помощью функции `sorted()` - `sorted(T)`
```python
>>> T = 1, 2, 3, 2, 4, 2
>>> T.index(2,4) # возвращает смешение объекта "2" после смещения 4
5
>>> T.count(2)
3
```
 В стандартном библиотечном модуле `collections` существует тип `nametuples` именованный кортеж, в немреализована возможность доступа к данным как по индексам так и по именованым полям как в словаре.
 ```python
>>> from collections import namedtuple
>>> Rec = namedtuple('Rec', ['name', 'age', 'jobs'])
>>> bob = Rec('Bob', age=40.5, jobs= ['dev', 'mgr'])
>>> bob
Rec(name='Bob', age=40.5, jobs=['dev', 'mgr'])
>>> bob[0], bob[2]
('Bob', ['dev', 'mgr'])
>>> bob.name, bob.jobs
('Bob', ['dev', 'mgr'])
 ```
 
 **Файлы**
 
 ![изображение](https://user-images.githubusercontent.com/116806816/203485131-5dbfb093-802a-4776-ab2e-5b792683eb70.png)
 
Для открытия файла в программе вызывается встроенная функция `open` с указанием имени внешнего файла и режима обработки. Вызов возвращает файловый объект, имеющий методы для передачи данных:
 ```python
 afile = open(имя_файла, режим)
 afile.метод()
 ```
 Режим: 
 - `r` чтобы открыть файл для текстового ввода
 - `w` чтобы создать и открыть файл для текстового ввода
 - `a` чтобы открыть файл для дополнения текстом вконце
 - если добавить `b` в строку режима, то разрешаем работу с двоичными данными
 - если добавить `+` в строку режима, то приведет к открытию файла для ввода и вывода.
 
 Данные прочитанные из файла всегда возвразаются в сценарий в виде строки.
 
 По умолчанию выходные файлы всегда буферизируются, а это значит, что записываемый текст может не сразу быть передан из памяти на диск — сбрасывание буферизированных данных на диск инициирует закрытие файла или вызов метода `flush`. Избежать буферизации позволяют дополнительные аргументы функции `open`, но тогда может пострадать производительность.
 
 Элементарный пример работы с файлами

 ```python
 >>> myfile = open('file_proba.txt', 'w') # Открытие файла создание/очистка
 >>> myfile.write('hello text file\n') # запись строки
16                                     # Питон возвращает количество записанных символов
>>> myfile.write('goodbay text file\n') # Ещё строка
18
>>> myfile.close() #Закрытие фала - сброс выходных буферов на диск.

>>> myfile = open('file_proba.txt')  # Открытие файла r принимается по умолчанию
>>> myfile.readline()
'hello text file\n'
>>> myfile.readline()
'goodbay text file\n'
>>> myfile.readline()
''                                  # пустая строка - конец файла.
 ```

 ```python
 >>> open('file_proba.txt').read() # чтение сразу всего файла в строковый объект
'hello text file\ngoodbay text file\n'
>>> print(open('file_proba.txt').read()) # дружественное пользователю отображение
hello text file
goodbay text file
```

 Использование файловых итераторов
 ``` python
 >>> for line in open('file_proba.txt'):
	print(line, end = '')

	
hello text file
goodbay text file
```
 Для указания пути файла уместно использовать неформатированые строки `r`, например
 
 `open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.txt')`
 
Файлы в действии. Запишем в файл разные типы данных:

```python
>>> x,y,z = 43,44,45
>>> s = 'spam'
>>> d={'a':1, 'b':2}
>>> l = [1,2,3,4]
>>> F = open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.txt', 'w')
>>> F.write(s + '\n')
>>> F.write('%s, %s, %s\n'%(x,y,z))
>>> F.write(str(l) + '$' + str(d) + '\n')
>>> F.close()
```
Посмотрим что получилось:
```python
chars = open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.txt').read()
```
А теперь достанем это:
```python
 >>> F = open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.txt')
>>> line = F.readline() #чтение одной строки
>>> line
'spam\n'
>>> line.strip()
'spam'
>>> line = F.readline() #чтение следующей строки
>>> line
'43, 44, 45\n'
[int(part) for part in line.split(',')] #strip не обязателен так как int игнорирует \n
[43, 44, 45]
>>> line = F.readline() #чтение 3ей строки
>>> line
"[1, 2, 3, 4]${'a': 1, 'b': 2}\n"
>>> parts = line.split('$')
>>> parts
['[1, 2, 3, 4]', "{'a': 1, 'b': 2}\n"]
  ```
  Используем `eval` — встроенную функцию, которая трактует строку как порцию исполняемого программного кода (формально как строку, содержащую выражение Python).
  
  ```python
>>> eval(parts[0])
[1, 2, 3, 4]
>>> objects = [eval(P) for P in parts]
>>> print(objects[0], type(objects[0]))
[1, 2, 3, 4] <class 'list'>
>>> print(objects[1], type(objects[1]))
{'a': 1, 'b': 2} <class 'dict'>
  ```
Конечным результатом всего разбора и преобразования является список нормальных объектов Python, а не строк, теперь мы можем применять к ним списковые и словарные операции в своем сценарии.
  
  Модуль pickle является более развитым инструментом, который позволяет сохранять почти любой объект Python в файл напрямую, не требуя с нашей стороны каких-либо преобразований в и из строки.	
```python
  >>> D = {'a':1, 'b':2}
>>> F = open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.pk1', 'wb')
>>> import pickle
>>> pickle.dump(D, F)
>>> F.close()
>>> F = open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.pk1', 'rb')
>>> E = pickle.load(F)
>>> E
{'a': 1, 'b': 2}
```
  
**JSON** популярный формат. обрабатывается стандартным модулем json

 ```python
 >>> rec # просто обычный dict
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'mgr'], 'age': 40.5}
>>> import json
>>> json.dumps(rec) # представление json
'{"name": {"first": "Bob", "last": "Smith"}, "job": ["dev", "mgr"], "age": 40.5}'
>>> json.dump(rec, fp=open(r'C:\Users\1\Desktop\Проект\Питухон\json.txt', 'w'), indent =4)
>>> p = json.load(open(r'C:\Users\1\Desktop\Проект\Питухон\json.txt'))
>>> p
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'mgr'], 'age': 40.5}
 ```
  
**Итоговая сводка по типам в Python**
 
Объекты последовательностей — строки, списки и кортежи — разделяют операции над последовательностями, такие как конкатенация, определение длины и индексация.

  ![изображение](https://user-images.githubusercontent.com/116806816/203540217-8abf29cd-a318-42a2-9cac-9c900b20d0ba.png)
 
* Операция == проверяет эквивалентность значений. Python выполняет проверку	эквивалентности, рекурсивно сравнивая все вложенные объекты. 	
* Операция is проверяет идентичность объектов. Python проверяет, являются ли два объекта на самом деле одним и тем же объектом (т.е. располагаются по тому же самому адресу в памяти).	

**Смысл понятий "истина" и "ложь"**
  ```
>>> False == 0
True
  ```
  ![изображение](https://user-images.githubusercontent.com/116806816/203546657-450e5c30-7cfa-4c15-81ec-53cdd2696351.png)

Т.е. число не равное 0 это True, остальные типы равны True пока они не пусты.  например если x - строка, то проверка `if x:` равносильна `if x != ''`.
  
**Типы данных в Python**
  
  ![изображение](https://user-images.githubusercontent.com/116806816/203548966-4e2d4bda-52e7-48f7-81b1-130f041d13c9.png)
  
  ![изображение](https://user-images.githubusercontent.com/116806816/203549106-391615b4-adae-4fd8-9475-613666b92f89.png)

  #Часть III. Операторы и синтаксис.
  
  ## Глава 10. Введение в операторы в Python.

![изображение](https://user-images.githubusercontent.com/116806816/203705531-478b33ab-82d8-499b-99a8-3e8679d2b084.png)

Все состовные операторы Python соблюдают общий синтаксический шаблон:
```Строка заголовка :
       Вложенный блок операторов
```
Делай отступы, не будь Си подобным програмистом.

Пример классического кода:
```python
while True:
	r = input('Write some: ')
	if r == 'stop': break #в одну строку!!!
	print(int(r)**2)
print('Bay')
```
Строковый метод isdigit() возвращает True , если все символы в строке str являются цифрами и есть хотя бы один символ (строка является не пустой и не состоит из пробелов), в противном случае False. 

Предугадаем ошибки в нашем коде:
```python
while True:
        r = input('Write some: ')
        if r == 'stop':
                break
        elif r.isdigit():
                print(int(r)**2)
        else:
                print('bad!')
print('Bay!')
```
Оператор `try`. Python сначала выполняет часть `try`, после чего либо часть `except` (если исключение произошло), либо часть `else` (если исключений не было).

```python
while True:
        r = input('Write some: ')
        if r == 'stop':
                break
        try:
                num = int(r)
        except:
                print('bad! '*10)
        else:
                print(num**2)
print('Bay!')
```

Ну и рефакторинг этого всего:

```python
while True:
        r = input('Write some: ')
        if r == 'stop': break
        try:
                print(float(r)**2)
        except:
                print('bad! '*10)
print('Bay!')
```

## Глава 11. Операторы присваивания, выражений и вывода.

Интересный синтаксис, сначала не понял, а потом как понял:

```python
>>> while L:
front, L = L[0], L[1:]
print(front, L)
```

**Расширенная распаковка**
В случае присваивания послеждовательностей можно пометить одно имя `*` что бы в него поместить весь оставщийся хвост последовательности. Хвост это не окончание, это все оставшиеся элементы. 
```python
>>> seq = [1,2,3,4]
>>> a,b,c,d = seq
>>> print(a,b,c,d)
1 2 3 4
>>> a,*b =seq
>>> print(a,b)
1 [2, 3, 4]
>>> *a,b = seq
>>> print(a,b)
[1, 2, 3] 4
>>> a,*b,c = seq
>>> print(a,b,c)
1 [2, 3] 4
```
Распаковка всегда возвращает список, а нарезание вернет последовательность того же типа. 

Рефакторнём предидущий пример:
```python
>>> L = [1,2,3,4]
>>> while L:
front,*L = L
print(front, L)

1 [2, 3, 4]
2 [3, 4]
3 [4]
4 []
```
Распаковка будет работать и в циклах `for`, например:	`for a,*b,c in [(1,2,3,4), (5,6,7,8)]:`

**Дополнительные присваивания**

![изображение](https://user-images.githubusercontent.com/116806816/203910950-f4d85ce3-e109-4396-9304-f69a4c48d791.png)

Важно помнить, что для списков `+=` равносильно `extend`, то есть меняет объект на месте, в то время как конкатенация создаст новый объект. Хорошо посмотри пример и все станет понятно
```python
>>> L = [1,2,3,4]
>>> M = L
>>> L.extend([5,6])
>>> M,L
([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6])
>>> L += 's'
>>> M,L
([1, 2, 3, 4, 5, 6, 's'], [1, 2, 3, 4, 5, 6, 's'])
>>> L = L + ['pam']
>>> M, L
([1, 2, 3, 4, 5, 6, 's'], [1, 2, 3, 4, 5, 6, 's', 'pam'])
```

**Соглашение по именованию**

* Имена, которые начинаются с одиночного подчеркивания (_Х), не импортируются оператором `from module import`.
* Имена с двумя подчеркиваниями в начале и конце (__ X__ ) являются системными именами, которые имеют особый смысл для интерпретатора.
* Имена, начинающиеся с двух подчеркиваний, но не оканчивающиеся ими (__ X), локализованы (“искажены”) для включения в себя классов (см. обсуждение псевдозакрытых атрибутов).
* Имя, состоящее из одиночного подчеркивания (_), хранит результат последнего	выражения при работе в интерактивном сеансе.

Ну и конечно читай PEP8.

**print**

В общем случае `принт` выглядит так
`print([object,...][, sep = ' '][, end = '\n'][, file = sys.stdout][, flush = False])`
элементы в квадратных скобках не обязательны ежле чо, а значения после `=` это стандартные, которые могут быть заменены.

`print` выводит в поток данных `file` текстовые представления одного или большего числа объектов `object`, разделенные строкой `sep`, за которыми следует строка `end`, сбрасывая или не сбрасывая буферизированный вывод согласно аргументу `flush`.
```python
>>> print(x,y,z, file = open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.txt', 'w'))
>>> print(open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.txt').read())
spam 99 ['eggs']
```

**Перенаправление потока**
```python
>>> import sys
>>> sys.stdout.write('hello \n')
hello
```
Эти дейсвтия равносильны вызову `print`. Мы можем перенаправить весь поток в сценарии:

  `sys.stdout = open(r'C:\Users\1\Desktop\Проект\Питухон\myfile.txt', 'a')`

## Глава 12. Проверки `if` и правила синтаксиса.

Мы бы могли организовать ветвление в словаре с помощью `get`
```pyton
>>> branch = {'spam': 1.25, 'ham': 1.99, 'eggs': 0.99}
>>> print(branch.get('spam', 'Bad choice'))
1.25
>>> print(branch.get('bacon', 'Bad choice'))
Bad choice
```
или с помощью `try`
```python
choice = 'bacon'
try:
    print(branch[choice])
except KeyError:
    print('Bad choice')
 ```
 А можем просто `if/elif/else`
```python
if choice in branch:
    print(branch[choice])
else:
    print('Bad choice')
```
Можно переносить условия на несколько строк нужно для этого круглую скобку открыть.
```python
if (x == 1, y == 2,
    z == 3, choice == 'spam'):
    print(branch['spam'])
```

**Значения истинности и булевские проверки**

Важно, что в Python:

* все объекты имеют булевские значения истины и лжи
* любое ненулевое число или непустой объект является истинным
* нулевые числа, пустые объекты и `None` считаются ложными
* сравнения и проверки на равенство применяются к структурам данных рекурсивно
* сравнения и проверки возвращают `True` или `False`
* булевские операции `and` и `or` возвращают объект истинного или ложного операнда
* булевские операции прекращают оценку как только резултат становится известным

`X and Y` - даст истину, если истинным являются и X, и Y.
`X or Y` - даст истину, если истинным являются  X или Y.
`not X` - даст истину, если X ложно.

```python
if x:
    a = y
else:
    a = z
```
тоже, но в короткой запси `a = y if x else z`

**OR AND**

При проверке `or` объекты оцениваются слева направо и возвращается первый истинный объект. После первого объекта проверка останавливается. Если левый операнд оказался ложным вернется правый каково бы его значение ни было.
```python
>>> 2 or 3, 3 or 2
(2, 3)
>>> [] or 3, [] or ()
(3, ())
```

При проверке `and` объекты оцениваются слева направо и возвращается первый ложный объект. После первого объекта проверка останавливается. Если левый операнд оказался истинным вернется правый каково бы его значение ни было.
```python
>>> 2 and 3, 3 and 2
(3, 2)
>>> 3 and [], [] and ()
([], [])
```

ПОДУМАЙ ВНИМАТЕЛЬНО
`A = ((X and Y) or Z)`

`[x for x in L if x]`

## Глава 13. Циклы `while` и `for`

  Оператор `while` многократно выполняет блок операторов (обычно с отступом) до тех пор, пока проверка в заголовочной части оценивается как истинное значение.
 
  ```python
while проверка:           # проверка цикла
    оперторы              # тело цикла
    if проверка: break    # выход из цикла с пропуском else
    if проверка: continue # Переход на проверку в начале цикла
else:                     # Необязательная часть else        
    операторы             # Выполняются, если не произведен выход из
                          # цикла с помощью break
  ```
  `break` - переходит за пределы ближайщего заключающего цикла немедленно.
  `continue` - переходит в начало ближайщего цикла (на строку заголовка цикла)
  `pass` - ничего не делает, просто оператор заполнитель
  `else` - блок, который выполняется только если происходит нормальный выход из цика (т.е. без `break`).
  
  Вместо `pass` можно ставить `...`. Вообще интересный объект `...` свой тип, не True и не False.
  
  Вывести только четные числа.
  ```python
>>> x =10
>>> while x:
...     x -= 1
...     if x%2: continue # если остаток равен не 0, то в начало
...     print(x, end = ' ')
8 6 4 2 0 
```
  `continue` аналог `goto` негативно влияет на читабельность кода. Нужно его аккуратнее использовать.
`else` выполниться даже если тело цикла ни разу не выполнилось то есть в заголовке сразу ложнлое утверждение.

**Циклы `for`**
```python
for цель in объект:       # присваивает цели элементы объекта
    операторы             # повторяемое тело цикла: использует цель
    if проверка: break    # выход из цикла с пропуском else
    if проверка: continue # Переход на проверку в начале цикла
else:                     # Необязательная часть else        
    операторы             # Выполняются, если не встретился break
```
Цикл `for` распакует всё что угодно
```python
>>> for ((a, b), с) in [([1, 2], 3), ['XY', 6] ]: print(a, b, с)
... 
1 2 3
X Y 6
```
```python
>>> for a,*b,c in [(1,2,3,4), (5,6,7,8)]: print(a,b,c)
... 
1 [2, 3] 4
5 [6, 7] 8
```
**Методики написания циклов**

* Встроенная функция `zip` возвращает серию кортежей из параллельных элементов, которые могут применяться для обхода множества последовательностей в цикле `for`.
* Встроенная функция `enumerate` генерирует значения и индексы элементов в итерируемом объекте, так что вести счет вручную не придется.
* Встроенная функция `mар` .
* Встроенная функция `range` итерируемый объект. Что бы получить список - нужно использовать `list(range())`.
>*В качестве общего правила запомните: всякий раз, когда это возможно, применяйте for вместо while, и не используйте вызовы range в циклах for кроме крайних случаев. Более простое решение практически всегда будет лучшим. Однако, как и в каждом хорошем правиле, есть масса исключений.*

Для посещения каждого второго или n-ного элемента списка монжно применить генератор `range(1,100,n)` указав нужный шаг. Но надо помнить и о красивейщем синтаксисе срезов 
`for c in S[::2]: print(c, end = ' ')` например.
  
Функция `zip` принимает одну или большее количество последовательностей в качестве аргументов и возвращает серию кортежей, объединяющих в пары параллельные элементы из указанных последовательностей.
```python
>>> L1 = list(range(1,5))
>>> L2 = list(range(5,9))
>>> list(zip(L1, L2))
[(1, 5), (2, 6), (3, 7), (4, 8)]
>>> for a,b in zip(L1,L2):
...     print(a, '--', b)
1 -- 5
2 -- 6
3 -- 7
4 -- 8
```
`zip` усекает результирующие кортежи по длине самой короткой последовательности, когда длины аргументов отличаются.
С помощью `zip` можно создавать и словари, синтаксис таков:
```python
keys = ['spam', 'eggs', 'toast']
vals = [1,3,5]
d = dict(zip(keys,vals))
```
ну или так:
```python
{k:v for (k,v) in zip(keys, vals)}
```
**`enumerate`**

Функция `enumerate` возвращает генераторный объект, который на каждом проходе цикла возвращает кортеж (индекс, значение).

```
for (i,l) in enumerate(open('test.txt')):
    print('%s) %s' %(i, l.rstrip()))

0) aaaaaa
1) bbbbb
2) ccccc
```

## Глава 14. Итерации и включения.

 *Итерируемый объект* - физическая последовательность, или объектом, который производит по одному результату за раз в контексте итерационного инструмента.
 
Любой объект с методом `__next__()` для перехода на следующий результат, который генерирует исключение `Stop Iteration` при достижении конца серии результатов, в Python считается итератором.

Самый простой способ чтения файла:
```python
>>> for line in open(r'C:\Users\1\Desktop\Проект\Питухон\proba.txt'): print(line, end = ' ')
```
Функция `next(arg)` == `arg.__next__()`

Протокод итерации Python

![изображение](https://user-images.githubusercontent.com/116806816/204206342-ab46312e-0157-4edb-b52e-26562b2eb60e.png)

Тут считается важным понять, что при итерации объекты мы получаем итератор (`__iter__()`) и собственно объект итератора (`__next()__`). Путано как то, но если посмотреть на примере:

```python
>>> L = [1, 2, 3, 4, 5]
>>> I = iter(L)
>>> type(I)
<class 'list_iterator'>
>>> I.__next__()
1
>>> I.__next__()
2
>>> type(I.__next__())
<class 'int'>
```
В последних версиях Python словари являются итерируемыми объектами с итератором, который автоматически возвращает по одному ключу за раз в контексте итерации.
```python
for key in D: print(key, D[key])```
```

**Списковые включения**

`L = [x+0 for x in L]` можно записать обычным  циклом `for`. Но списковые включения могут работать быстрее чем просто `for` т.к. они функционируют со скоростью  кода на языке C,  а `for` со скоростью Pythin. Объяснить этого не могут даже самые опытные экстрасенсы, но факт.

Выражения могут быть и сложненее:
```python
>>> [('sys' in line, line[:5]) for line in open(r'proba.txt')]
[(True, 'impor'), (True, 'print'), (False, 'x = 2'), (False, 'print')]
```
С конструкцией `if`
```python
>>> lines = [line.rstrip() for line in open('proba.txt') if line[0] == 'p']
>>> lines
['print(sys.path)', 'print(x**32)']
```
**`for` вложенный в списковое включение** механик_из_west_coast_customs.jpeg
```python
>>> [x+y for x in 'abc' for y in 'lmn']
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
```
что бы это понять, можем представить в виде цикла `for`
```python
>>> res = []
>>> for x in 'abc':
	for y in 'lmn':
		res.append(x+y)
>>> res
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
```
**Другие итерационные контексты**
  
  `range()` возвращает итерируемый объект, можно сосздать сколь угодно много его итераторов:
```python
>>> r = range(10)
>>> i1 = iter(r)
>>> i2= iter(r)
>>> i1.__next__()
0
>>> i1.__next__()
1
>>> i1.__next__()
2
>>> i1.__next__()
3
>>> i2.__next__()
0
>>> list(i1)
[4, 5, 6, 7, 8, 9]
>>> list(i2)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```
  
 `map`, `zip`, `filter`  - собственные итераторы. Результаты после одноразового прохода по ним израсходуются. 
  
  
  ## Глава 15. Документация.
  
`#` подходит для комментирования строк или небольшой группы операторов, но не более того.

`dir()` можно вызвать и без аргументов, он покажет переменные в зоне видимости.

`b = [x for x in dir(str) if x[:2] != '__']` посмотреть все методы `str` которые не начинаются с `__`

**`__doc__`** запрос документации. Например:
```pyrhon
>>> print(print.__doc__)
print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

Prints the values to a stream, or to sys.stdout by default.
Optional keyword arguments:
file:  a file-like object (stream); defaults to the current sys.stdout.
sep:   string inserted between values, default a space.
end:   string appended after the last value, default a newline.
flush: whether to forcibly flush the stream.
```
Полный результат получим если напишем `help(print)`
Чтобы извлечь строку документации метода из класса внутри модуля, понадобится просто указать путь к классу: 

`модуль.класс.метод.__doc__`	
`% c:\code> python -m pydoc -b` Ну у меня не запустился встроеный браузер. Не уверен что он вообще нужен.

# Часть 4. Функции и генераторы.

## Глава 16. Основы функций.
  
Функция - способ группирования набора операторов, позволяющим выполнять их более одного раза в программе — упакованной процедурой, вызываемой по имени.	

![изображение](https://user-images.githubusercontent.com/116806816/204507855-8d615279-a5ae-49ea-8968-a12b88060d84.png)

**Оператор `def`** создает объект функции и присваивает его имени. Общий формат `def` выглядит следующим образом:
```python
  def имя(аргумент1, аргумент2, ..., аргументN):
      операторы
      return #не всегда он тут присутствует
```
  Оператор `def` можно вкладыват даже в ветвление `if`
  ```python
  if test:
      def func():
  else:
      def func():
  
  func()
```
Наша простая функция пересечения множеств
  ```python
  def intersect(seq1, seq2):
    res = []
    for x in seq1:
        if x in seq2:
            res.append(x)
    return res
>>> s1 = 'spam'
>>> s2 = 'scram'
>>> intersect(s1,s2)
['s', 'a', 'm']
  ```
 Вместо строк мы можем передать списки или другие последовательности и всё будет работать. Это *полиморфизм*.
 
 Передача неприемлемых аргументов автоматически приведет к исключению и это хорошо. 
  
  В нашей функции есть локальные переменные, то есть те которые существуют только во время выполнения функции. Это: `seq1`, `seq2`, `res` и `x`. А вот `s1` и `s2` это глобальные переменные.
  
## Глава 17. Области видимости.
  
  Лексическая оласть видимости:
  
* если переменная присваивается внутри `def`, то она будет локальной в этой функции
* если переменная присваивается в объемлющем `def`, тогда она будет нелокальной в отношении вложенных функций
* если переменная присваивается за пределами всех `def`, то она будет глобальной в целом файле

По умолчанию все имена, присвоенные внутри определения функции, помещаются в локальную область видимости (пространство имен, ассоциированное с вызовом функции). Если необходимо присвоить имя, которое существует на верхнем уровне модуля, включающего в себя функцию, тогда такое имя можно объявить как глобальное в операторе `global` внутри функции. Если нужно присвоить имя, находящееся в объемлющем операторе `def`, то имя можно объявить как нелокальное в операторе `nonlocal`.	

Правило LEGB

![изображение](https://user-images.githubusercontent.com/116806816/204718044-b09be8ea-7030-4425-bf1f-0112f3cefbf4.png)

```python
>>> x = 10
>>> def ff(y):
	z = x+y
	return z
>>> ff(3)
13
>>> l = [x for x in range(10)]
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> x
10
>>> for x in range(5):
	pass
>>> x
4
```
`x`, `ff`, `l` - это глобальные переменные.
`x` в включениях локальная, это не та, которая глобальная а новая, своя `x`. Напротив в цикле for `x` - глобальная и в итоге меняет свое значение на 4.

Если вы случайно переопределили встроенное имя в интерактивной подсказке, тогда можете либо перезапустить свой сеанс, либо выполнить оператор `del(имя)` имя и удалить переопределение из своей области видимости, тем самым восстановив оригинал из встроенной области видимости.

**`global`**

```python
>>> z,y = 1,2
>>> def qqq():
	global x # создаётся глобальная переменная
	x = z + y
>>> x
27
>>> qqq()
>>> x # функция qqq() повлияла на глобальный x
3
```
**Фабричная функция**
```python
>>> def f1(x):
	      def f2(y):
		        return x*y
	      return f2

>>> f = f1(2)
>>> f
<function f1.<locals>.f2 at 0x0000000002EEA940>
>>> f(5)
10
>>> f1(3)(5)
15
>>> q = f1(5)
>>> q(5)
25
```
Каждый вызов фабричной функции получает собственный набор информации о состоянии.

* Оператор `global` заставляет поиск в областях видимости начинаться в области видимости включающего модуля и открывает возможность присваивания находящимся там именам. Если имя не существует в модуле, тогда поиск продолжается во встроенной области видимости, но присваивания глобальным именам	всегда создают или изменяют их в области видимости модуля.
* Оператор `nonlocal` ограничивает поиск в областях видимости только объемлющими `def`, требует, чтобы имена уже там существовали, и делает возможным присваивание им значений. Поиск не продолжается в глобальной или встроенной областях видимости.

Применение нелокадьных переменных для запоминания состояния:
```python
>>> def teaster(start):
	state = start
	def nested(label):
		nonlocal state
		print(label, state)
		state += 1
	return nested

>>> f = teaster(1)
>>> f('a')
a 1
>>> f('b')
b 2
>>> c = teaster(15)
>>> c('c')
c 15
>>> f('d')
d 3
```
Далее муть мутная. Сохранение состояния и вот это вот всё.

## Глав 18. Аргументы.

Для передачи аргументов кортежем, необходимо записывапть ожидаемую структуру кортежа:
```python 
t = (1, (2,3)) # этот кортеж хотим передать будушей функции
def f(T): (a, (b,c)) = T # создавать функцию будем так.
```
**Сопоставление аргументов**

По умолчанию аргументы сопоставляются по позиции, слева направо, и необходимо передавать ровно столько аргументов, сколько есть имен аргументов в заголовке функции. Однако можно также задавать сопоставление по имени, предоставлять стандартные значения и использовать собиратели для добавочных аргументов.

![изображение](https://user-images.githubusercontent.com/116806816/204980177-f14fcf1c-3d7c-4503-bd1d-acdedad0644e.png)

В вызове функции аргументы должны указываться в следующем порядке: любые позиционные аргументы (значение), за ними комбинация любых ключевых аргументов (имя=значение) и формы \*итерируемый_объект, а затем форма	
\*\*словарь. 			
```python
>>> def f(a,b,c): print(a,b,c)
>>> f(1,2,3) # сопоставление по позиции
1 2 3
>>> f(c=3, b=2, a=1) # сопоставление по ключевым словам
1 2 3
>>> f(1, c=3, b=2)  # сначала все позиционные затем по именам 
1 2 3
>>> def f(a,b=2,c=3): print(a,b,c) # b,c - стандартные значения
>>> f(1) # b,c присваиваются стандартные значения
1 2 3
>>> f(1, c=5) # b присваивается стандартное значение, с переопределяем
1 2 5
>>> f(1,7) # переопределение стандартных сначений по порядку.
1 7 3
>>> def f(*args): print(args)	 # сбор несопоставленных позиционных аргументов в кортеж:
>>> f()
()
>>> f(1,2,3,4,5,6)
(1, 2, 3, 4, 5, 6)
>>> def f(**args): print(args) # сбор аргументов в словарь:
>>> f()
{}
>>> f(a=1, b=2)
{'a': 1, 'b': 2}
```
Комбинирование:
```python
>>> def f(a, *pargs, **kargs): print(a, pargs, kargs)
>>> f(1,2,3, x=1, y=2)
1 (2, 3) {'x': 1, 'y': 2}
```
**Использование \* при распаковке аргументов**
```python
>>> def f(a,b,c,d): print(a,b,c,d)
>>> args=(1,2,3,4)
>>> f(*args) # кортеж распаковывается попозиционно
1 2 3 4
>>> args = {'a':1, 'b':2, 'c':3, 'd':4}
>>> f(**args) # словарь распаковывает значения по наименованию ключей (a = args['a'] и т.д.)
1 2 3 4
```
Комбинирование:
```python
>>> f(*(1,2), **{'d':4, 'c':3})
1 2 3 4
>>> f(1, *(2,3), **{'d':4})
1 2 3 4
>>> f(1,*(2,), c=3, **{'d':4})
1 2 3 4
```
Помним одна \* - позиционный аргументб \*\* - ключевой аргумент.

```python
>>> def tracer(f, *pargs, **kargs):
	print('calling: ', f.__name__)
	return f(*pargs, **kargs)

>>> def f(a,b,c,d):
	return a+b+c+d
>>> print(tracer(f, 1,2,c=3, d=4))
calling:  f
10
```
В этом примере мы вызываем функцию `tracer` и передаём ей аргументы `f` - `функция f`, `*pargs = (1,2,)`, `**kargs = {c:3,d:4}`.

**Аргументы с передачей только по ключевому слову**
```python
>>> def f(a,*b,c):
	print(a,b,c)
>>> f(1,2, c=3)
1 (2,) 3
>>> f(a=1,c=3)
1 () 3
>>> f(1,2,3)
TypeError: f() missing 1 required keyword-only argument: 'c'
```
если поместить аргумент `*` про описании функции, то аргументы следующие за `*` должны будут передаваться усключительно по имени.
```python
>>> def f(a,*,b,c):
	print(a,b,c)
>>> f(1, b=2, c=3)
1 2 3
```
Удобно так задавать не обязательные аргументы.
```python
>>> def f(a,*, b=2, c=3):
	print(a,b,c)
>>> f(1)
1 2 3
```
Запуск функции с 2 и более неименоваными аргументами вызовет ошибку. Но вот обратившись к по имени можно изменить значение необязательных аргументов.

Комбинирование:
```python
>>> def f(a, *b, c = 6, **d): print(a,b,c,d)
>>> f(1, 2, 3, 4, 5, x=7, y=8)
1 (2, 3, 4, 5) 6 {'x': 7, 'y': 8}
```

